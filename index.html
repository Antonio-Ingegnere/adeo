<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Adeo</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="card">
      <div class="content-grid">
        <div class="lists-rail">
          <div class="lists-panel">
            <div class="lists-header">
              <div class="lists-title-wrap">
                <button id="lists-toggle" class="icon-button" aria-label="Toggle lists">
                  <span class="expand-chevrons" aria-hidden="true">
                    <svg viewBox="0 0 14 14" focusable="false">
                      <path d="M2 3 L7 8 L12 3" />
                      <path d="M2 8 L7 13 L12 8" />
                    </svg>
                  </span>
                </button>
                <p class="lists-title">Lists</p>
              </div>
              <button id="add-list-button" class="icon-button" aria-label="Add list">+</button>
            </div>
            <div id="lists-list" class="lists-list">
              <div id="lists-empty" class="empty-state">No lists yet. Click + to add one.</div>
            </div>
          </div>
        </div>
        <div class="main-column">
          <div class="main-body">
            <div class="input-row">
              <input id="message-input" type="text" placeholder="Add a new task" class="text-input" />
              <select id="add-task-list" class="select-input">
                <option value="">No list</option>
              </select>
              <button id="add-button" class="primary-button">Add</button>
            </div>
            <div id="tasks" class="tasks-section">
              <p class="tasks-title">All tasks</p>
              <div id="tasks-list" class="tasks-list">
                <div id="empty-state" class="empty-state">Nothing added yet. Enter a task and hit Add.</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="edit-overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
          <div class="modal-content">
            <div class="modal-body">
              <div class="modal-left">
                <div class="modal-title-row">
                  <input id="edit-done" type="checkbox" />
                  <input id="edit-input" type="text" class="text-input modal-input" />
                </div>
                <div class="modal-details">
                <label for="edit-details" class="modal-label">Details</label>
                <textarea
                  id="edit-details"
                  rows="4"
                  class="details-textarea"
                  placeholder="Add optional task details in Markdown"
                ></textarea>
                </div>
              </div>
              <div class="modal-right">
                <div class="modal-right-content">
                  <h3>List</h3>
                  <select id="modal-list-select" class="select-input" style="width: 100%;">
                    <option value="">No list</option>
                  </select>
                  <hr class="modal-list-divider" />
                </div>
              </div>
            </div>
            <div class="modal-actions">
              <button id="cancel-edit" class="btn icon-btn" aria-label="Cancel">✕</button>
              <button id="save-edit" class="btn primary icon-btn" aria-label="Save">
                <svg class="icon-check" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path
                    d="M20.285 6.708a1 1 0 0 0-1.57-1.25L9.75 15.09l-3.465-3.37a1 1 0 1 0-1.39 1.44l4.2 4.083a1 1 0 0 0 1.42-.03l9.77-10.505Z"
                  />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
      <div id="list-overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal modal-small">
          <h2>Add list</h2>
          <input id="list-input" type="text" class="text-input modal-input" placeholder="List name" />
          <div class="modal-actions">
            <button id="cancel-list" class="btn icon-btn" aria-label="Cancel list">✕</button>
            <button id="save-list" class="btn primary icon-btn" aria-label="Save list">
              <svg class="icon-check" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path
                  d="M20.285 6.708a1 1 0 0 0-1.57-1.25L9.75 15.09l-3.465-3.37a1 1 0 1 0-1.39 1.44l4.2 4.083a1 1 0 0 0 1.42-.03l9.77-10.505Z"
                />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
    <script>
      const input = document.getElementById('message-input');
      const button = document.getElementById('add-button');

      const tasks = [];
      const tasksList = document.getElementById('tasks-list');
      const emptyState = document.getElementById('empty-state');
      const overlay = document.getElementById('edit-overlay');
      const editInput = document.getElementById('edit-input');
      const editDoneInput = document.getElementById('edit-done');
      const editDetailsInput = document.getElementById('edit-details');
      const cancelEditBtn = document.getElementById('cancel-edit');
      const saveEditBtn = document.getElementById('save-edit');
      const dropIndicator = document.createElement('div');
      dropIndicator.className = 'drop-indicator';
      const listsList = document.getElementById('lists-list');
      const listsEmpty = document.getElementById('lists-empty');
      const listsToggle = document.getElementById('lists-toggle');
      const addListBtn = document.getElementById('add-list-button');
      const listOverlay = document.getElementById('list-overlay');
      const listInput = document.getElementById('list-input');
      const cancelListBtn = document.getElementById('cancel-list');
      const saveListBtn = document.getElementById('save-list');
      const addTaskListSelect = document.getElementById('add-task-list');
      const modalListSelect = document.getElementById('modal-list-select');
      let editingTaskId = null;
      let dragIndex = null;
      let dropIndex = null;
      const expandedDetails = new Set();
      let showCompleted = true;
      let lists = [];
      let listsExpanded = true;
      let selectedListId = null;
      const tasksTitleEl = document.querySelector('.tasks-title');
      let editingListId = null;
      let modalSelectedListId = null;
      let addTaskSelectedListId = null;

      const escapeHtml = (text) =>
        text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

      const renderInline = (text) => {
        return text
          .replace(/`([^`]+)`/g, '<code>$1</code>')
          .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
          .replace(/\*([^*]+)\*/g, '<em>$1</em>');
      };

      const renderDetailsElement = (task) => {
        const container = document.createElement('div');
        container.className = 'task-details';
        const lines = (task.details || '').split(/\r?\n/);
        let currentList = null;
        const closeList = () => {
          if (currentList) {
            container.appendChild(currentList);
            currentList = null;
          }
        };

        const updateCheckboxLine = async (lineIndex, checked) => {
          const original = lines[lineIndex] || '';
          const updated = original.replace(/^\s*(?:-|\*)?\s*\[\s?[xX ]\s?\]/, checked ? '- [x]' : '- [ ]');
          lines[lineIndex] = updated;
          const newDetails = lines.join('\n');
          task.details = newDetails;
          try {
            await window.electronAPI.updateTaskDetails(task.id, newDetails);
            renderTasks();
          } catch (error) {
            console.error('Failed to update task detail checkbox', error);
          }
        };

        lines.forEach((line, index) => {
          const hrMatch = line.match(/^\s*-{3,}\s*$/);
          if (hrMatch) {
            closeList();
            const hr = document.createElement('hr');
            hr.className = 'md-hr';
            container.appendChild(hr);
            return;
          }

          const headerMatch = line.match(/^(#{1,6})\s+(.*)/);
          if (headerMatch) {
            closeList();
            const level = Math.min(headerMatch[1].length, 6);
            const h = document.createElement(`h${level}`);
            h.innerHTML = renderInline(escapeHtml(headerMatch[2]));
            container.appendChild(h);
            return;
          }

          const taskMatch = line.match(/^\s*(?:-|\*)?\s*\[\s?([xX ])\s?\]\s+(.*)/);
          if (taskMatch) {
            if (currentList?.dataset.type !== 'task') {
              closeList();
              currentList = document.createElement('ul');
              currentList.className = 'task-list';
              currentList.dataset.type = 'task';
            }
            const li = document.createElement('li');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = taskMatch[1].toLowerCase() === 'x';
            checkbox.addEventListener('change', (event) => {
              updateCheckboxLine(index, event.target.checked);
            });
            const span = document.createElement('span');
            span.innerHTML = renderInline(escapeHtml(taskMatch[2]));
            li.appendChild(checkbox);
            li.appendChild(span);
            currentList.appendChild(li);
            return;
          }

          const listMatch = line.match(/^\s*[-*]\s+(.*)/);
          if (listMatch) {
            if (currentList?.dataset.type !== 'bullet') {
              closeList();
              currentList = document.createElement('ul');
              currentList.dataset.type = 'bullet';
            }
            const li = document.createElement('li');
            li.innerHTML = renderInline(escapeHtml(listMatch[1]));
            currentList.appendChild(li);
            return;
          }

          if (line.trim() === '') {
            closeList();
            container.appendChild(document.createElement('br'));
            return;
          }

          closeList();
          const p = document.createElement('p');
          p.innerHTML = renderInline(escapeHtml(line));
          container.appendChild(p);
        });

        closeList();
        return container;
      };

      const getVisibleTasks = () => {
        let base = showCompleted ? tasks : tasks.filter((t) => !t.done);
        if (selectedListId !== null) {
          base = base.filter((t) => t.listId === selectedListId);
        }
        return base;
      };

      const updateTasksTitle = () => {
        if (!tasksTitleEl) return;
        if (selectedListId === null) {
          tasksTitleEl.textContent = 'All tasks';
          return;
        }
        const list = lists.find((l) => l.id === selectedListId);
        tasksTitleEl.textContent = list ? list.name : 'Tasks';
      };

      const renderListOptions = (selectEl, selectedId) => {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        const noneOption = document.createElement('option');
        noneOption.value = '';
        noneOption.textContent = 'No list';
        selectEl.appendChild(noneOption);
        lists.forEach((list) => {
          const option = document.createElement('option');
          option.value = String(list.id);
          const fullName = list.name;
          const truncated = fullName.length > 30 ? `${fullName.slice(0, 30)}...` : fullName;
          option.textContent = truncated;
          if (truncated !== fullName) {
            option.title = fullName;
          }
          selectEl.appendChild(option);
        });
        if (selectedId !== null) {
          selectEl.value = String(selectedId);
        } else {
          selectEl.value = '';
        }
      };

      const removeDropIndicator = () => {
        if (dropIndicator.parentNode) {
          dropIndicator.parentNode.removeChild(dropIndicator);
        }
      };

      const renderLists = () => {
        if (!listsList) return;
        listsList.innerHTML = '';
        if (!listsExpanded) {
          listsList.style.display = 'none';
          return;
        }
        listsList.style.display = 'flex';
        const makeLabel = (text) => {
          const span = document.createElement('span');
          span.className = 'list-pill-label';
          const truncated = text.length > 30 ? `${text.slice(0, 30)}...` : text;
          span.textContent = truncated;
          if (truncated !== text) {
            span.title = text;
          }
          return span;
        };
        const allItem = document.createElement('div');
        allItem.className = `list-pill${selectedListId === null ? ' selected' : ''}`;
        allItem.appendChild(makeLabel('All lists'));
        allItem.addEventListener('click', () => {
          selectedListId = null;
          updateTasksTitle();
          renderLists();
          renderTasks();
        });
        listsList.appendChild(allItem);

        if (lists.length === 0) {
          if (listsEmpty) {
            listsList.appendChild(listsEmpty);
          }
          return;
        }
        lists.forEach((list) => {
          const item = document.createElement('div');
          const isSelected = selectedListId === list.id;
          item.className = `list-pill${isSelected ? ' selected' : ''}`;
          item.appendChild(makeLabel(typeof list === 'string' ? list : list.name));
          item.addEventListener('click', () => {
            selectedListId = list.id;
            addTaskSelectedListId = list.id;
            updateTasksTitle();
            renderLists();
            renderListOptions(addTaskListSelect, addTaskSelectedListId);
            renderTasks();
          });
          item.addEventListener('dblclick', () => openEditListModal(list.id));
          listsList.appendChild(item);
        });
      };

      const renderModalLists = () => {
        if (!modalListSelect) return;
        renderListOptions(modalListSelect, modalSelectedListId);
      };

      const saveTaskOrder = async () => {
        try {
          const orderedIds = tasks.map((task) => task.id);
          tasks.forEach((task, index) => {
            task.position = index;
          });
          await window.electronAPI.updateTaskOrder(orderedIds);
        } catch (error) {
          console.error('Failed to save task order', error);
        }
      };

      const renderTasks = () => {
        if (!tasksList) return;

        removeDropIndicator();
        tasksList.innerHTML = '';

        const visibleTasks = getVisibleTasks();

        if (visibleTasks.length === 0) {
          if (emptyState) {
            tasksList.appendChild(emptyState);
          }
          return;
        }

        visibleTasks.forEach((task) => {
          const index = tasks.findIndex((t) => t.id === task.id);
          if (index === -1) return;
          const row = document.createElement('div');
          row.className = 'task-row';
          row.dataset.index = String(index);

          const handle = document.createElement('span');
          handle.className = 'drag-handle';
          handle.title = 'Drag to reorder';
          handle.setAttribute('draggable', 'true');
          handle.addEventListener('dragstart', (event) => {
            dragIndex = index;
            row.classList.add('dragging');
            event.dataTransfer?.setData('text/plain', String(index));
            event.dataTransfer?.setDragImage(row, 10, 10);
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = 'move';
            }
          });
          handle.addEventListener('dragend', () => {
            dragIndex = null;
            dropIndex = null;
            row.classList.remove('dragging');
            removeDropIndicator();
          });

          row.addEventListener('dragover', (event) => {
            event.preventDefault();
            const rect = row.getBoundingClientRect();
            const isBefore = event.clientY < rect.top + rect.height / 2;
            const targetIndex = Number(row.dataset.index);
            dropIndex = isBefore ? targetIndex : targetIndex + 1;
            removeDropIndicator();
            if (row.parentNode) {
              if (isBefore) {
                row.parentNode.insertBefore(dropIndicator, row);
              } else {
                row.parentNode.insertBefore(dropIndicator, row.nextSibling);
              }
            }
            if (event.dataTransfer) {
              event.dataTransfer.dropEffect = 'move';
            }
          });
          row.addEventListener('dragleave', () => {});
          row.addEventListener('drop', (event) => {
            event.preventDefault();
            removeDropIndicator();
            if (dragIndex === null || dropIndex === null) {
              return;
            }
            if (dragIndex === dropIndex || dragIndex + 1 === dropIndex) {
              dragIndex = null;
              dropIndex = null;
              return;
            }
            const [moved] = tasks.splice(dragIndex, 1);
            const adjustedIndex = dragIndex < dropIndex ? dropIndex - 1 : dropIndex;
            tasks.splice(adjustedIndex, 0, moved);
            dragIndex = null;
            dropIndex = null;
            renderTasks();
            saveTaskOrder();
          });

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = task.done;
          checkbox.addEventListener('change', async (event) => {
            const checked = event.target.checked;
            tasks[index].done = checked;
            textSpan.style.textDecoration = checked ? 'line-through' : 'none';
            try {
              await window.electronAPI.updateTaskDone(task.id, checked);
            } catch (error) {
              console.error('Failed to update task status', error);
            }
          });

          const textSpan = document.createElement('span');
          textSpan.textContent = task.text;
          textSpan.className = 'task-text';
          textSpan.style.textDecoration = task.done ? 'line-through' : 'none';
          textSpan.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            openEditModal(task.id);
          });

          const detailsDiv = renderDetailsElement(task);
          const hasDetails = Boolean(task.details?.trim());
          const isExpanded = expandedDetails.has(task.id);
          detailsDiv.style.display = hasDetails && isExpanded ? 'block' : 'none';

          const mainBlock = document.createElement('div');
          mainBlock.className = 'task-main';
          mainBlock.appendChild(textSpan);
          if (hasDetails) {
            mainBlock.appendChild(detailsDiv);
          }

          row.appendChild(handle);
          row.appendChild(checkbox);
          row.appendChild(mainBlock);

          if (hasDetails) {
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'expand-btn';
            toggleBtn.title = isExpanded ? 'Collapse details' : 'Expand details';
            const iconWrapper = document.createElement('span');
            iconWrapper.className = 'expand-chevrons';
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 14 14');
            svg.setAttribute('focusable', 'false');
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const setPaths = (expanded) => {
              if (expanded) {
                path1.setAttribute('d', 'M2 8 L7 3 L12 8');
                path2.setAttribute('d', 'M2 13 L7 8 L12 13');
              } else {
                path1.setAttribute('d', 'M2 3 L7 8 L12 3');
                path2.setAttribute('d', 'M2 8 L7 13 L12 8');
              }
            };
            setPaths(isExpanded);
            svg.appendChild(path1);
            svg.appendChild(path2);
            iconWrapper.appendChild(svg);
            toggleBtn.appendChild(iconWrapper);
            toggleBtn.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (expandedDetails.has(task.id)) {
                expandedDetails.delete(task.id);
              } else {
                expandedDetails.add(task.id);
              }
              renderTasks();
            });
            row.appendChild(toggleBtn);
          }
          tasksList.appendChild(row);
        });
      };

      const addTask = async () => {
        const text = input?.value.trim();
        if (!text) return;

        try {
          const createdTask = await window.electronAPI.addTask(text, addTaskSelectedListId ?? selectedListId);
          if (!createdTask || createdTask.error) {
            return;
          }

          tasks.push(createdTask);
          if (input) {
            input.value = '';
            input.focus();
          }
          renderTasks();
        } catch (error) {
          console.error('Failed to add task', error);
        }
      };

      const openEditModal = (taskId) => {
        const task = tasks.find((t) => t.id === taskId);
        if (!overlay || !editInput || !editDetailsInput || !task) return;
        editingTaskId = taskId;
        modalSelectedListId = task.listId ?? null;
        editInput.value = task.text;
        editDetailsInput.value = task.details || '';
        if (editDoneInput) {
          editDoneInput.checked = task.done;
        }
        overlay.classList.add('open');
        renderModalLists();
        setTimeout(() => editInput.focus(), 0);
      };

      const closeEditModal = () => {
        if (!overlay || !editInput || !editDetailsInput) return;
        overlay.classList.remove('open');
        editInput.value = '';
        editDetailsInput.value = '';
        if (editDoneInput) {
          editDoneInput.checked = false;
        }
        editingTaskId = null;
        modalSelectedListId = null;
      };

      const saveEdit = async () => {
        if (!editingTaskId || !editInput || !editDetailsInput) return;
        const newText = editInput.value.trim();
        const newDetails = editDetailsInput.value;
        const newListId = modalSelectedListId;
        const newDone = editDoneInput?.checked ?? false;
        if (!newText) return;
        try {
          const [textResult, detailsResult, listResult] = await Promise.all([
            window.electronAPI.updateTaskText(editingTaskId, newText),
            window.electronAPI.updateTaskDetails(editingTaskId, newDetails),
            window.electronAPI.updateTaskList(editingTaskId, newListId),
            window.electronAPI.updateTaskDone(editingTaskId, newDone),
          ]);
          if (!textResult || textResult.error || !detailsResult || listResult?.error) {
            return;
          }
          const idx = tasks.findIndex((t) => t.id === editingTaskId);
          if (idx !== -1) {
            tasks[idx].text = newText;
            tasks[idx].details = newDetails;
            tasks[idx].listId = listResult?.listId ?? null;
            tasks[idx].done = newDone;
            renderTasks();
          }
          closeEditModal();
        } catch (error) {
          console.error('Failed to update task text', error);
        }
      };

      const openListModal = () => {
        if (!listOverlay || !listInput) return;
        listOverlay.classList.add('open');
        listInput.value = '';
        setTimeout(() => listInput.focus(), 0);
      };

      const openEditListModal = (listId) => {
        const list = lists.find((l) => l.id === listId);
        if (!list || !listOverlay || !listInput) return;
        editingListId = listId;
        listOverlay.classList.add('open');
        listInput.value = list.name;
        setTimeout(() => listInput.focus(), 0);
      };

      const closeListModal = () => {
        if (!listOverlay || !listInput) return;
        listOverlay.classList.remove('open');
        listInput.value = '';
        editingListId = null;
      };

      const saveList = () => {
        if (!listInput) return;
        const name = listInput.value.trim();
        if (!name) return;
        if (editingListId) {
          window.electronAPI
            .updateListName(editingListId, name)
            .then((updated) => {
              if (!updated || updated.error) return;
              const idx = lists.findIndex((l) => l.id === editingListId);
              if (idx !== -1) {
                lists[idx].name = updated.name;
              }
              if (selectedListId === editingListId) {
                updateTasksTitle();
              }
              closeListModal();
              renderLists();
              renderListOptions(addTaskListSelect, addTaskSelectedListId ?? selectedListId);
              renderModalLists();
            })
            .catch((error) => console.error('Failed to update list', error));
        } else {
          window.electronAPI
            .addList(name)
            .then((created) => {
              if (!created || created.error) return;
              lists.push({ id: created.id, name: created.name });
              closeListModal();
              renderLists();
              renderListOptions(addTaskListSelect, addTaskSelectedListId ?? selectedListId);
              renderModalLists();
            })
            .catch((error) => console.error('Failed to add list', error));
        }
      };

      const loadTasks = async () => {
        try {
          const existingTasks = await window.electronAPI.getTasks();
          tasks.splice(0, tasks.length, ...existingTasks);
          tasks.forEach((t) => {
            if (t.listId === undefined) {
              t.listId = null;
            }
          });
          renderTasks();
        } catch (error) {
          console.error('Failed to load tasks', error);
        }
      };

      const loadSettings = async () => {
        try {
          const settings = await window.electronAPI.getSettings();
          showCompleted = settings.showCompleted;
          renderTasks();
        } catch (error) {
          console.error('Failed to load settings', error);
        }
      };

      const loadLists = async () => {
        try {
          const existingLists = await window.electronAPI.getLists();
          lists = existingLists ?? [];
          renderLists();
          updateTasksTitle();
          renderListOptions(addTaskListSelect, addTaskSelectedListId ?? selectedListId);
        } catch (error) {
          console.error('Failed to load lists', error);
        }
      };

      tasksList?.addEventListener('dragover', (event) => {
        event.preventDefault();
        const visibleTasks = getVisibleTasks();
        if (visibleTasks.length === 0) {
          dropIndex = 0;
          removeDropIndicator();
          tasksList.appendChild(dropIndicator);
        } else if (event.target === tasksList) {
          const lastVisible = visibleTasks[visibleTasks.length - 1];
          const lastVisibleIndex = tasks.findIndex((t) => t.id === lastVisible.id);
          dropIndex = lastVisibleIndex + 1;
          removeDropIndicator();
          tasksList.appendChild(dropIndicator);
        }
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
      });
      tasksList?.addEventListener('drop', (event) => {
        event.preventDefault();
        if (dragIndex === null || dropIndex === null) {
          removeDropIndicator();
          return;
        }
        const [moved] = tasks.splice(dragIndex, 1);
        const adjustedIndex = dragIndex < dropIndex ? dropIndex - 1 : dropIndex;
        tasks.splice(adjustedIndex, 0, moved);
        dragIndex = null;
        dropIndex = null;
        renderTasks();
        saveTaskOrder();
        removeDropIndicator();
      });

      button?.addEventListener('click', addTask);
      input?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          addTask();
        }
      });

      cancelEditBtn?.addEventListener('click', () => closeEditModal());
      saveEditBtn?.addEventListener('click', () => saveEdit());
      editInput?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          saveEdit();
        }
      });
      overlay?.addEventListener('click', (event) => {
        if (event.target === overlay) {
          closeEditModal();
        }
      });

      window.electronAPI.onShowCompletedChanged((value) => {
        showCompleted = value;
        renderTasks();
      });

      listsToggle?.addEventListener('click', () => {
        listsExpanded = !listsExpanded;
        const icon = listsToggle.querySelector('svg path:first-of-type');
        const icon2 = listsToggle.querySelector('svg path:last-of-type');
        if (listsExpanded) {
          icon?.setAttribute('d', 'M2 3 L7 8 L12 3');
          icon2?.setAttribute('d', 'M2 8 L7 13 L12 8');
        } else {
          icon?.setAttribute('d', 'M2 8 L7 3 L12 8');
          icon2?.setAttribute('d', 'M2 13 L7 8 L12 13');
        }
        renderLists();
      });

      addListBtn?.addEventListener('click', () => openListModal());
      saveListBtn?.addEventListener('click', () => saveList());
      cancelListBtn?.addEventListener('click', () => closeListModal());
      listInput?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          saveList();
        }
      });
      listOverlay?.addEventListener('click', (event) => {
        if (event.target === listOverlay) {
          closeListModal();
        }
      });

      addTaskListSelect?.addEventListener('change', (event) => {
        const val = event.target.value;
        addTaskSelectedListId = val ? Number(val) : null;
      });

      modalListSelect?.addEventListener('change', (event) => {
        const val = event.target.value;
        modalSelectedListId = val ? Number(val) : null;
      });

      loadSettings().then(() => loadTasks());
      loadLists();
      // Initialize lists chevrons orientation
      listsToggle?.dispatchEvent(new Event('click'));
      listsToggle?.dispatchEvent(new Event('click'));
      renderLists();
      renderModalLists();
      renderListOptions(addTaskListSelect, addTaskSelectedListId ?? selectedListId);
    </script>
  </body>
</html>
