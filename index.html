<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello World</title>
    <style>
      body {
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        font-family: Arial, sans-serif;
        background: #f5f5f5;
      }
      .card {
        padding: 24px 32px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        background: #fff;
        text-align: center;
      }
      .headline {
        font-size: 28px;
        margin: 0 0 8px;
        color: #222;
      }
      .meta {
        margin: 0;
        color: #666;
        font-size: 14px;
      }
      .task-text {
        color: #222;
        font-size: 14px;
        cursor: pointer;
      }
      .task-text:hover {
        color: #1d72f3;
      }
      .tasks-list {
        display: flex;
        flex-direction: column;
        gap: 0;
        background: #fafafa;
        border: 1px solid #e8e8e8;
        border-radius: 10px;
        overflow: hidden;
      }
      .task-row {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        padding: 10px 12px;
        border-bottom: 1px solid #e0e0e0;
      }
      .task-row:last-child {
        border-bottom: none;
      }
      .task-row input[type='checkbox'] {
        margin: 2px 0 0;
      }
      .task-row.drag-over {
        background: #eef3ff;
      }
      .task-row.dragging {
        opacity: 0.6;
      }
      .drop-indicator {
        height: 3px;
        background: #4a8ef7;
        border-radius: 999px;
        margin: 0 12px;
      }
      .drag-handle {
        width: 14px;
        height: 14px;
        display: inline-block;
        background: repeating-linear-gradient(
          to bottom,
          #b0b0b0 0,
          #b0b0b0 1px,
          transparent 1px,
          transparent 5px
        );
        cursor: grab;
        flex-shrink: 0;
        margin-top: 2px;
      }
      .expand-btn {
        margin-left: auto;
        border: none;
        background: transparent;
        cursor: pointer;
        color: #666;
        display: inline-flex;
        align-items: center;
        padding: 4px;
      }
      .expand-btn:hover {
        color: #1d72f3;
      }
      .task-main {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .task-details {
        color: #555;
        font-size: 13px;
        line-height: 1.4;
        text-align: left;
      }
      .task-details ul {
        margin: 4px 0 0;
        padding-left: 18px;
      }
      .task-details p {
        margin: 2px 0;
      }
      .task-details code {
        background: #f0f0f0;
        padding: 0 4px;
        border-radius: 4px;
        font-size: 12px;
      }
      .task-details strong {
        font-weight: 600;
      }
      .task-details .task-list {
        list-style: none;
        padding-left: 0;
        margin: 4px 0 0;
      }
      .task-details .task-list li {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .task-details .task-list input[type='checkbox'] {
        pointer-events: none;
        margin: 0;
      }
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }
      .overlay.open {
        display: flex;
      }
      .modal {
        background: #fff;
        border-radius: 12px;
        padding: 20px;
        width: min(420px, 100%);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      }
      .modal h2 {
        margin: 0 0 12px;
        font-size: 18px;
        color: #111;
      }
      .modal-actions {
        margin-top: 14px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .btn {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #d6d6d6;
        background: #f7f7f7;
        cursor: pointer;
        font-size: 14px;
      }
      .btn.primary {
        border: none;
        background: #1d72f3;
        color: #fff;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <h1 class="headline">Hello World</h1>
      <p class="meta">Electron v<span id="app-version">...</span></p>
      <div style="margin-top: 16px; display: flex; gap: 8px;">
        <input
          id="message-input"
          type="text"
          placeholder="Type a message"
          style="flex: 1; padding: 8px 12px; font-size: 14px; border: 1px solid #ccc; border-radius: 8px;"
        />
        <button
          id="add-button"
          style="padding: 8px 14px; font-size: 14px; border: none; border-radius: 8px; background: #1d72f3; color: #fff; cursor: pointer;"
        >
          Add
        </button>
      </div>
      <div id="tasks" style="margin-top: 20px; text-align: left;">
        <p style="margin: 0 0 8px; color: #444; font-weight: 600;">All tasks</p>
        <div id="tasks-list" class="tasks-list">
          <div
            id="empty-state"
            style="padding: 10px 12px; border: 1px dashed #d6d6d6; border-radius: 8px; color: #777;"
          >
            Nothing added yet. Enter a task and hit Add.
          </div>
        </div>
      </div>
      <div id="edit-overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
          <h2>Edit task</h2>
          <input
            id="edit-input"
            type="text"
            style="width: 100%; padding: 10px 12px; font-size: 14px; border: 1px solid #ccc; border-radius: 8px;"
          />
          <div style="margin-top: 12px; text-align: left;">
            <label for="edit-details" style="display: block; margin-bottom: 6px; color: #333; font-weight: 600;">
              Details (Markdown supported)
            </label>
            <textarea
              id="edit-details"
              rows="4"
              style="width: 100%; padding: 10px 12px; font-size: 14px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"
            ></textarea>
          </div>
          <div class="modal-actions">
            <button id="cancel-edit" class="btn">Cancel</button>
            <button id="save-edit" class="btn primary">Save</button>
          </div>
        </div>
      </div>
    </div>
    <script>
      const input = document.getElementById('message-input');
      const button = document.getElementById('add-button');

      const tasks = [];
      const tasksList = document.getElementById('tasks-list');
      const emptyState = document.getElementById('empty-state');
      const overlay = document.getElementById('edit-overlay');
      const editInput = document.getElementById('edit-input');
      const editDetailsInput = document.getElementById('edit-details');
      const cancelEditBtn = document.getElementById('cancel-edit');
      const saveEditBtn = document.getElementById('save-edit');
      const dropIndicator = document.createElement('div');
      dropIndicator.className = 'drop-indicator';
      let editingTaskId = null;
      let dragIndex = null;
      let dropIndex = null;
      const expandedDetails = new Set();

      const escapeHtml = (text) =>
        text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

      const renderInline = (text) => {
        return text
          .replace(/`([^`]+)`/g, '<code>$1</code>')
          .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
          .replace(/\*([^*]+)\*/g, '<em>$1</em>');
      };

      const renderMarkdown = (text) => {
        const escaped = escapeHtml(text || '');
        const lines = escaped.split(/\r?\n/);
        let html = '';
        let inList = false;
        let inTaskList = false;

        const closeList = () => {
          if (inList) {
            html += '</ul>';
            inList = false;
          }
          if (inTaskList) {
            html += '</ul>';
            inTaskList = false;
          }
        };

        lines.forEach((line) => {
          const listMatch = line.match(/^\s*[-*]\s+(.*)/);
          const taskMatch = line.match(/^\s*(?:-|\*)?\s*\[\s?([xX ])\s?\]\s+(.*)/);
          const headerMatch = line.match(/^(#{1,6})\s+(.*)/);

          if (headerMatch) {
            closeList();
            const level = headerMatch[1].length;
            const content = renderInline(headerMatch[2]);
            html += `<h${level}>${content}</h${level}>`;
            return;
          }

          if (taskMatch) {
            if (inList) {
              html += '</ul>';
              inList = false;
            }
            if (!inTaskList) {
              html += '<ul class="task-list">';
              inTaskList = true;
            }
            const checked = taskMatch[1].toLowerCase() === 'x';
            html += `<li><input type="checkbox" disabled ${checked ? 'checked' : ''} /> ${renderInline(
              taskMatch[2]
            )}</li>`;
            return;
          }

          if (listMatch) {
            if (inTaskList) {
              html += '</ul>';
              inTaskList = false;
            }
            if (!inList) {
              html += '<ul>';
              inList = true;
            }
            html += `<li>${renderInline(listMatch[1])}</li>`;
          } else if (line.trim() === '') {
            closeList();
            html += '<br>';
          } else {
            closeList();
            html += `<p>${renderInline(line)}</p>`;
          }
        });

        closeList();
        return html;
      };

      const removeDropIndicator = () => {
        if (dropIndicator.parentNode) {
          dropIndicator.parentNode.removeChild(dropIndicator);
        }
      };

      const saveTaskOrder = async () => {
        try {
          const orderedIds = tasks.map((task) => task.id);
          tasks.forEach((task, index) => {
            task.position = index;
          });
          await window.electronAPI.updateTaskOrder(orderedIds);
        } catch (error) {
          console.error('Failed to save task order', error);
        }
      };

      const renderTasks = () => {
        if (!tasksList) return;

        removeDropIndicator();
        tasksList.innerHTML = '';

        if (tasks.length === 0) {
          if (emptyState) {
            tasksList.appendChild(emptyState);
          }
          return;
        }

        tasks.forEach((task, index) => {
          const label = document.createElement('label');
          label.className = 'task-row';
          label.dataset.index = String(index);

          const handle = document.createElement('span');
          handle.className = 'drag-handle';
          handle.title = 'Drag to reorder';
          handle.setAttribute('draggable', 'true');
          handle.addEventListener('dragstart', (event) => {
            dragIndex = index;
            label.classList.add('dragging');
            event.dataTransfer?.setData('text/plain', String(index));
            event.dataTransfer?.setDragImage(label, 10, 10);
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = 'move';
            }
          });
          handle.addEventListener('dragend', () => {
            dragIndex = null;
            dropIndex = null;
            label.classList.remove('dragging');
            removeDropIndicator();
          });

          label.addEventListener('dragover', (event) => {
            event.preventDefault();
            const rect = label.getBoundingClientRect();
            const isBefore = event.clientY < rect.top + rect.height / 2;
            const targetIndex = Number(label.dataset.index);
            dropIndex = isBefore ? targetIndex : targetIndex + 1;
            removeDropIndicator();
            if (label.parentNode) {
              if (isBefore) {
                label.parentNode.insertBefore(dropIndicator, label);
              } else {
                label.parentNode.insertBefore(dropIndicator, label.nextSibling);
              }
            }
            if (event.dataTransfer) {
              event.dataTransfer.dropEffect = 'move';
            }
          });
          label.addEventListener('dragleave', () => {});
          label.addEventListener('drop', (event) => {
            event.preventDefault();
            removeDropIndicator();
            if (dragIndex === null || dropIndex === null) {
              return;
            }
            if (dragIndex === dropIndex || dragIndex + 1 === dropIndex) {
              dragIndex = null;
              dropIndex = null;
              return;
            }
            const [moved] = tasks.splice(dragIndex, 1);
            const adjustedIndex = dragIndex < dropIndex ? dropIndex - 1 : dropIndex;
            tasks.splice(adjustedIndex, 0, moved);
            dragIndex = null;
            dropIndex = null;
            renderTasks();
            saveTaskOrder();
          });

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = task.done;
          checkbox.addEventListener('change', async (event) => {
            const checked = event.target.checked;
            tasks[index].done = checked;
            textSpan.style.textDecoration = checked ? 'line-through' : 'none';
            try {
              await window.electronAPI.updateTaskDone(task.id, checked);
            } catch (error) {
              console.error('Failed to update task status', error);
            }
          });

          const textSpan = document.createElement('span');
          textSpan.textContent = task.text;
          textSpan.className = 'task-text';
          textSpan.style.textDecoration = task.done ? 'line-through' : 'none';
          textSpan.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            openEditModal(task.id);
          });

          const detailsDiv = document.createElement('div');
          detailsDiv.className = 'task-details';
          detailsDiv.innerHTML = renderMarkdown(task.details || '');
          const hasDetails = Boolean(task.details?.trim());
          const isExpanded = expandedDetails.has(task.id);
          detailsDiv.style.display = hasDetails && isExpanded ? 'block' : 'none';

          const mainBlock = document.createElement('div');
          mainBlock.className = 'task-main';
          mainBlock.appendChild(textSpan);
          if (hasDetails) {
            mainBlock.appendChild(detailsDiv);
          }

          label.appendChild(handle);
          label.appendChild(checkbox);
          label.appendChild(mainBlock);

          if (hasDetails) {
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'expand-btn';
            toggleBtn.title = isExpanded ? 'Collapse details' : 'Expand details';
            toggleBtn.innerHTML = isExpanded ? '&#9650;' : '&#9660;';
            toggleBtn.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (expandedDetails.has(task.id)) {
                expandedDetails.delete(task.id);
              } else {
                expandedDetails.add(task.id);
              }
              renderTasks();
            });
            label.appendChild(toggleBtn);
          }
          tasksList.appendChild(label);
        });
      };

      const addTask = async () => {
        const text = input?.value.trim();
        if (!text) return;

        try {
          const createdTask = await window.electronAPI.addTask(text);
          if (!createdTask || createdTask.error) {
            return;
          }

          tasks.push(createdTask);
          if (input) {
            input.value = '';
            input.focus();
          }
          renderTasks();
        } catch (error) {
          console.error('Failed to add task', error);
        }
      };

      const openEditModal = (taskId) => {
        const task = tasks.find((t) => t.id === taskId);
        if (!overlay || !editInput || !editDetailsInput || !task) return;
        editingTaskId = taskId;
        editInput.value = task.text;
        editDetailsInput.value = task.details || '';
        overlay.classList.add('open');
        setTimeout(() => editInput.focus(), 0);
      };

      const closeEditModal = () => {
        if (!overlay || !editInput || !editDetailsInput) return;
        overlay.classList.remove('open');
        editInput.value = '';
        editDetailsInput.value = '';
        editingTaskId = null;
      };

      const saveEdit = async () => {
        if (!editingTaskId || !editInput || !editDetailsInput) return;
        const newText = editInput.value.trim();
        const newDetails = editDetailsInput.value;
        if (!newText) return;
        try {
          const [textResult] = await Promise.all([
            window.electronAPI.updateTaskText(editingTaskId, newText),
            window.electronAPI.updateTaskDetails(editingTaskId, newDetails),
          ]);
          if (!textResult || textResult.error) {
            return;
          }
          const idx = tasks.findIndex((t) => t.id === editingTaskId);
          if (idx !== -1) {
            tasks[idx].text = newText;
            tasks[idx].details = newDetails;
            renderTasks();
          }
          closeEditModal();
        } catch (error) {
          console.error('Failed to update task text', error);
        }
      };

      const loadTasks = async () => {
        try {
          const existingTasks = await window.electronAPI.getTasks();
          tasks.splice(0, tasks.length, ...existingTasks);
          renderTasks();
        } catch (error) {
          console.error('Failed to load tasks', error);
        }
      };

      tasksList?.addEventListener('dragover', (event) => {
        event.preventDefault();
        if (tasks.length === 0) {
          dropIndex = 0;
          removeDropIndicator();
          tasksList.appendChild(dropIndicator);
        } else if (event.target === tasksList) {
          dropIndex = tasks.length;
          removeDropIndicator();
          tasksList.appendChild(dropIndicator);
        }
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
      });
      tasksList?.addEventListener('drop', (event) => {
        event.preventDefault();
        if (dragIndex === null || dropIndex === null) {
          removeDropIndicator();
          return;
        }
        const [moved] = tasks.splice(dragIndex, 1);
        const adjustedIndex = dragIndex < dropIndex ? dropIndex - 1 : dropIndex;
        tasks.splice(adjustedIndex, 0, moved);
        dragIndex = null;
        dropIndex = null;
        renderTasks();
        saveTaskOrder();
        removeDropIndicator();
      });

      button?.addEventListener('click', addTask);
      input?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          addTask();
        }
      });

      cancelEditBtn?.addEventListener('click', () => closeEditModal());
      saveEditBtn?.addEventListener('click', () => saveEdit());
      editInput?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          saveEdit();
        }
      });
      overlay?.addEventListener('click', (event) => {
        if (event.target === overlay) {
          closeEditModal();
        }
      });

      loadTasks();
    </script>
  </body>
</html>
