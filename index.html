<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Adeo</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="card">
      <h1 class="headline">Hello World</h1>
      <p class="meta">Electron v<span id="app-version">...</span></p>
      <div class="content-grid">
        <div class="projects-panel">
          <div class="projects-header">
            <div class="projects-title-wrap">
              <button id="projects-toggle" class="icon-button" aria-label="Toggle projects">▸</button>
              <p class="projects-title">Projects</p>
            </div>
            <button id="add-project-button" class="icon-button" aria-label="Add project">+</button>
          </div>
          <div id="projects-list" class="projects-list">
            <div id="projects-empty" class="empty-state">No projects yet. Click + to add one.</div>
          </div>
        </div>
        <div>
          <div class="input-row">
            <input id="message-input" type="text" placeholder="Type a message" class="text-input" />
            <button id="add-button" class="primary-button">Add</button>
          </div>
          <div id="tasks" class="tasks-section">
            <p class="tasks-title">All tasks</p>
            <div id="tasks-list" class="tasks-list">
              <div id="empty-state" class="empty-state">Nothing added yet. Enter a task and hit Add.</div>
            </div>
          </div>
        </div>
      </div>
      <div id="edit-overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
          <h2>Edit task</h2>
          <input id="edit-input" type="text" class="text-input modal-input" />
          <div class="modal-details">
            <label for="edit-details" class="modal-label">Details (Markdown supported)</label>
            <textarea id="edit-details" rows="4" class="details-textarea"></textarea>
          </div>
          <div class="modal-actions">
            <button id="cancel-edit" class="btn">Cancel</button>
            <button id="save-edit" class="btn primary">Save</button>
          </div>
        </div>
      </div>
      <div id="project-overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
          <h2>Add project</h2>
          <input id="project-input" type="text" class="text-input modal-input" placeholder="Project name" />
          <div class="modal-actions">
            <button id="cancel-project" class="btn">Cancel</button>
            <button id="save-project" class="btn primary">Save</button>
          </div>
        </div>
      </div>
    </div>
    <script>
      const input = document.getElementById('message-input');
      const button = document.getElementById('add-button');

      const tasks = [];
      const tasksList = document.getElementById('tasks-list');
      const emptyState = document.getElementById('empty-state');
      const overlay = document.getElementById('edit-overlay');
      const editInput = document.getElementById('edit-input');
      const editDetailsInput = document.getElementById('edit-details');
      const cancelEditBtn = document.getElementById('cancel-edit');
      const saveEditBtn = document.getElementById('save-edit');
      const dropIndicator = document.createElement('div');
      dropIndicator.className = 'drop-indicator';
      const projectsList = document.getElementById('projects-list');
      const projectsEmpty = document.getElementById('projects-empty');
      const projectsToggle = document.getElementById('projects-toggle');
      const addProjectBtn = document.getElementById('add-project-button');
      const projectOverlay = document.getElementById('project-overlay');
      const projectInput = document.getElementById('project-input');
      const cancelProjectBtn = document.getElementById('cancel-project');
      const saveProjectBtn = document.getElementById('save-project');
      let editingTaskId = null;
      let dragIndex = null;
      let dropIndex = null;
      const expandedDetails = new Set();
      let showCompleted = true;
      let projects = [];
      let projectsExpanded = true;

      const escapeHtml = (text) =>
        text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

      const renderInline = (text) => {
        return text
          .replace(/`([^`]+)`/g, '<code>$1</code>')
          .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
          .replace(/\*([^*]+)\*/g, '<em>$1</em>');
      };

      const renderDetailsElement = (task) => {
        const container = document.createElement('div');
        container.className = 'task-details';
        const lines = (task.details || '').split(/\r?\n/);
        let currentList = null;
        const closeList = () => {
          if (currentList) {
            container.appendChild(currentList);
            currentList = null;
          }
        };

        const updateCheckboxLine = async (lineIndex, checked) => {
          const original = lines[lineIndex] || '';
          const updated = original.replace(/^\s*(?:-|\*)?\s*\[\s?[xX ]\s?\]/, checked ? '- [x]' : '- [ ]');
          lines[lineIndex] = updated;
          const newDetails = lines.join('\n');
          task.details = newDetails;
          try {
            await window.electronAPI.updateTaskDetails(task.id, newDetails);
            renderTasks();
          } catch (error) {
            console.error('Failed to update task detail checkbox', error);
          }
        };

        lines.forEach((line, index) => {
          const hrMatch = line.match(/^\s*-{3,}\s*$/);
          if (hrMatch) {
            closeList();
            const hr = document.createElement('hr');
            hr.className = 'md-hr';
            container.appendChild(hr);
            return;
          }

          const headerMatch = line.match(/^(#{1,6})\s+(.*)/);
          if (headerMatch) {
            closeList();
            const level = Math.min(headerMatch[1].length, 6);
            const h = document.createElement(`h${level}`);
            h.innerHTML = renderInline(escapeHtml(headerMatch[2]));
            container.appendChild(h);
            return;
          }

          const taskMatch = line.match(/^\s*(?:-|\*)?\s*\[\s?([xX ])\s?\]\s+(.*)/);
          if (taskMatch) {
            if (currentList?.dataset.type !== 'task') {
              closeList();
              currentList = document.createElement('ul');
              currentList.className = 'task-list';
              currentList.dataset.type = 'task';
            }
            const li = document.createElement('li');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = taskMatch[1].toLowerCase() === 'x';
            checkbox.addEventListener('change', (event) => {
              updateCheckboxLine(index, event.target.checked);
            });
            const span = document.createElement('span');
            span.innerHTML = renderInline(escapeHtml(taskMatch[2]));
            li.appendChild(checkbox);
            li.appendChild(span);
            currentList.appendChild(li);
            return;
          }

          const listMatch = line.match(/^\s*[-*]\s+(.*)/);
          if (listMatch) {
            if (currentList?.dataset.type !== 'bullet') {
              closeList();
              currentList = document.createElement('ul');
              currentList.dataset.type = 'bullet';
            }
            const li = document.createElement('li');
            li.innerHTML = renderInline(escapeHtml(listMatch[1]));
            currentList.appendChild(li);
            return;
          }

          if (line.trim() === '') {
            closeList();
            container.appendChild(document.createElement('br'));
            return;
          }

          closeList();
          const p = document.createElement('p');
          p.innerHTML = renderInline(escapeHtml(line));
          container.appendChild(p);
        });

        closeList();
        return container;
      };

      const getVisibleTasks = () => (showCompleted ? tasks : tasks.filter((t) => !t.done));

      const removeDropIndicator = () => {
        if (dropIndicator.parentNode) {
          dropIndicator.parentNode.removeChild(dropIndicator);
        }
      };

      const renderProjects = () => {
        if (!projectsList) return;
        projectsList.innerHTML = '';
        if (!projectsExpanded) {
          projectsList.style.display = 'none';
          return;
        }
        projectsList.style.display = 'flex';
        if (projects.length === 0) {
          if (projectsEmpty) {
            projectsList.appendChild(projectsEmpty);
          }
          return;
        }
        projects.forEach((project) => {
          const item = document.createElement('div');
          item.className = 'project-pill';
          item.textContent = project;
          projectsList.appendChild(item);
        });
      };

      const saveTaskOrder = async () => {
        try {
          const orderedIds = tasks.map((task) => task.id);
          tasks.forEach((task, index) => {
            task.position = index;
          });
          await window.electronAPI.updateTaskOrder(orderedIds);
        } catch (error) {
          console.error('Failed to save task order', error);
        }
      };

      const renderTasks = () => {
        if (!tasksList) return;

        removeDropIndicator();
        tasksList.innerHTML = '';

        const visibleTasks = getVisibleTasks();

        if (visibleTasks.length === 0) {
          if (emptyState) {
            tasksList.appendChild(emptyState);
          }
          return;
        }

        visibleTasks.forEach((task) => {
          const index = tasks.findIndex((t) => t.id === task.id);
          if (index === -1) return;
          const row = document.createElement('div');
          row.className = 'task-row';
          row.dataset.index = String(index);

          const handle = document.createElement('span');
          handle.className = 'drag-handle';
          handle.title = 'Drag to reorder';
          handle.setAttribute('draggable', 'true');
          handle.addEventListener('dragstart', (event) => {
            dragIndex = index;
            row.classList.add('dragging');
            event.dataTransfer?.setData('text/plain', String(index));
            event.dataTransfer?.setDragImage(row, 10, 10);
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = 'move';
            }
          });
          handle.addEventListener('dragend', () => {
            dragIndex = null;
            dropIndex = null;
            row.classList.remove('dragging');
            removeDropIndicator();
          });

          row.addEventListener('dragover', (event) => {
            event.preventDefault();
            const rect = row.getBoundingClientRect();
            const isBefore = event.clientY < rect.top + rect.height / 2;
            const targetIndex = Number(row.dataset.index);
            dropIndex = isBefore ? targetIndex : targetIndex + 1;
            removeDropIndicator();
            if (row.parentNode) {
              if (isBefore) {
                row.parentNode.insertBefore(dropIndicator, row);
              } else {
                row.parentNode.insertBefore(dropIndicator, row.nextSibling);
              }
            }
            if (event.dataTransfer) {
              event.dataTransfer.dropEffect = 'move';
            }
          });
          row.addEventListener('dragleave', () => {});
          row.addEventListener('drop', (event) => {
            event.preventDefault();
            removeDropIndicator();
            if (dragIndex === null || dropIndex === null) {
              return;
            }
            if (dragIndex === dropIndex || dragIndex + 1 === dropIndex) {
              dragIndex = null;
              dropIndex = null;
              return;
            }
            const [moved] = tasks.splice(dragIndex, 1);
            const adjustedIndex = dragIndex < dropIndex ? dropIndex - 1 : dropIndex;
            tasks.splice(adjustedIndex, 0, moved);
            dragIndex = null;
            dropIndex = null;
            renderTasks();
            saveTaskOrder();
          });

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = task.done;
          checkbox.addEventListener('change', async (event) => {
            const checked = event.target.checked;
            tasks[index].done = checked;
            textSpan.style.textDecoration = checked ? 'line-through' : 'none';
            try {
              await window.electronAPI.updateTaskDone(task.id, checked);
            } catch (error) {
              console.error('Failed to update task status', error);
            }
          });

          const textSpan = document.createElement('span');
          textSpan.textContent = task.text;
          textSpan.className = 'task-text';
          textSpan.style.textDecoration = task.done ? 'line-through' : 'none';
          textSpan.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            openEditModal(task.id);
          });

          const detailsDiv = renderDetailsElement(task);
          const hasDetails = Boolean(task.details?.trim());
          const isExpanded = expandedDetails.has(task.id);
          detailsDiv.style.display = hasDetails && isExpanded ? 'block' : 'none';

          const mainBlock = document.createElement('div');
          mainBlock.className = 'task-main';
          mainBlock.appendChild(textSpan);
          if (hasDetails) {
            mainBlock.appendChild(detailsDiv);
          }

          row.appendChild(handle);
          row.appendChild(checkbox);
          row.appendChild(mainBlock);

          if (hasDetails) {
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'expand-btn';
            toggleBtn.title = isExpanded ? 'Collapse details' : 'Expand details';
            const iconWrapper = document.createElement('span');
            iconWrapper.className = 'expand-chevrons';
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 14 14');
            svg.setAttribute('focusable', 'false');
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const setPaths = (expanded) => {
              if (expanded) {
                path1.setAttribute('d', 'M2 8 L7 3 L12 8');
                path2.setAttribute('d', 'M2 13 L7 8 L12 13');
              } else {
                path1.setAttribute('d', 'M2 3 L7 8 L12 3');
                path2.setAttribute('d', 'M2 8 L7 13 L12 8');
              }
            };
            setPaths(isExpanded);
            svg.appendChild(path1);
            svg.appendChild(path2);
            iconWrapper.appendChild(svg);
            toggleBtn.appendChild(iconWrapper);
            toggleBtn.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (expandedDetails.has(task.id)) {
                expandedDetails.delete(task.id);
              } else {
                expandedDetails.add(task.id);
              }
              renderTasks();
            });
            row.appendChild(toggleBtn);
          }
          tasksList.appendChild(row);
        });
      };

      const addTask = async () => {
        const text = input?.value.trim();
        if (!text) return;

        try {
          const createdTask = await window.electronAPI.addTask(text);
          if (!createdTask || createdTask.error) {
            return;
          }

          tasks.push(createdTask);
          if (input) {
            input.value = '';
            input.focus();
          }
          renderTasks();
        } catch (error) {
          console.error('Failed to add task', error);
        }
      };

      const openEditModal = (taskId) => {
        const task = tasks.find((t) => t.id === taskId);
        if (!overlay || !editInput || !editDetailsInput || !task) return;
        editingTaskId = taskId;
        editInput.value = task.text;
        editDetailsInput.value = task.details || '';
        overlay.classList.add('open');
        setTimeout(() => editInput.focus(), 0);
      };

      const closeEditModal = () => {
        if (!overlay || !editInput || !editDetailsInput) return;
        overlay.classList.remove('open');
        editInput.value = '';
        editDetailsInput.value = '';
        editingTaskId = null;
      };

      const saveEdit = async () => {
        if (!editingTaskId || !editInput || !editDetailsInput) return;
        const newText = editInput.value.trim();
        const newDetails = editDetailsInput.value;
        if (!newText) return;
        try {
          const [textResult] = await Promise.all([
            window.electronAPI.updateTaskText(editingTaskId, newText),
            window.electronAPI.updateTaskDetails(editingTaskId, newDetails),
          ]);
          if (!textResult || textResult.error) {
            return;
          }
          const idx = tasks.findIndex((t) => t.id === editingTaskId);
          if (idx !== -1) {
            tasks[idx].text = newText;
            tasks[idx].details = newDetails;
            renderTasks();
          }
          closeEditModal();
        } catch (error) {
          console.error('Failed to update task text', error);
        }
      };

      const openProjectModal = () => {
        if (!projectOverlay || !projectInput) return;
        projectOverlay.classList.add('open');
        projectInput.value = '';
        setTimeout(() => projectInput.focus(), 0);
      };

      const closeProjectModal = () => {
        if (!projectOverlay || !projectInput) return;
        projectOverlay.classList.remove('open');
        projectInput.value = '';
      };

      const saveProject = () => {
        if (!projectInput) return;
        const name = projectInput.value.trim();
        if (!name) return;
        projects.push(name);
        closeProjectModal();
        renderProjects();
      };

      const loadTasks = async () => {
        try {
          const existingTasks = await window.electronAPI.getTasks();
          tasks.splice(0, tasks.length, ...existingTasks);
          renderTasks();
        } catch (error) {
          console.error('Failed to load tasks', error);
        }
      };

      const loadSettings = async () => {
        try {
          const settings = await window.electronAPI.getSettings();
          showCompleted = settings.showCompleted;
          renderTasks();
        } catch (error) {
          console.error('Failed to load settings', error);
        }
      };

      tasksList?.addEventListener('dragover', (event) => {
        event.preventDefault();
        const visibleTasks = getVisibleTasks();
        if (visibleTasks.length === 0) {
          dropIndex = 0;
          removeDropIndicator();
          tasksList.appendChild(dropIndicator);
        } else if (event.target === tasksList) {
          const lastVisible = visibleTasks[visibleTasks.length - 1];
          const lastVisibleIndex = tasks.findIndex((t) => t.id === lastVisible.id);
          dropIndex = lastVisibleIndex + 1;
          removeDropIndicator();
          tasksList.appendChild(dropIndicator);
        }
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
      });
      tasksList?.addEventListener('drop', (event) => {
        event.preventDefault();
        if (dragIndex === null || dropIndex === null) {
          removeDropIndicator();
          return;
        }
        const [moved] = tasks.splice(dragIndex, 1);
        const adjustedIndex = dragIndex < dropIndex ? dropIndex - 1 : dropIndex;
        tasks.splice(adjustedIndex, 0, moved);
        dragIndex = null;
        dropIndex = null;
        renderTasks();
        saveTaskOrder();
        removeDropIndicator();
      });

      button?.addEventListener('click', addTask);
      input?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          addTask();
        }
      });

      cancelEditBtn?.addEventListener('click', () => closeEditModal());
      saveEditBtn?.addEventListener('click', () => saveEdit());
      editInput?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          saveEdit();
        }
      });
      overlay?.addEventListener('click', (event) => {
        if (event.target === overlay) {
          closeEditModal();
        }
      });

      window.electronAPI.onShowCompletedChanged((value) => {
        showCompleted = value;
        renderTasks();
      });

      projectsToggle?.addEventListener('click', () => {
        projectsExpanded = !projectsExpanded;
        projectsToggle.textContent = projectsExpanded ? '▾' : '▸';
        renderProjects();
      });

      addProjectBtn?.addEventListener('click', () => openProjectModal());
      saveProjectBtn?.addEventListener('click', () => saveProject());
      cancelProjectBtn?.addEventListener('click', () => closeProjectModal());
      projectInput?.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
          saveProject();
        }
      });
      projectOverlay?.addEventListener('click', (event) => {
        if (event.target === projectOverlay) {
          closeProjectModal();
        }
      });

      loadSettings().then(() => loadTasks());
      projectsToggle.textContent = projectsExpanded ? '▾' : '▸';
      renderProjects();
    </script>
  </body>
</html>
